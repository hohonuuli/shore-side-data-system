#summary Design details regarding the Ruminate component of the SSDS
#sidebar TableOfContents

= Introduction =

The Ruminate component of the SSDS was designed to be the handler for incoming metadata messages from SSDS clients.  When metadata arrives, Ruminate is tasked to examine everything in the message and performa a sequence of steps to ensure that the metadata is recorded (persisted) in the SSDS appropriately.  The incoming metadata packets should have an XML payload that conforms to the SSDS Metadata Schema in order for it to be handled correctly (otherwise it will be ignored).

= Details =

After transmogrify and ingest deal with the incoming stream of packets and record them in the database, the message, if metadata, gets forwarded on to the JMS topic where the Ruminate Message Driven Bean (MDB) is listening.  The MDB is responsible for a sequence of steps in order to make sure the incoming metadata is understood and is accurately reflected in the persistent store of the SSDS database.

A fundamental thing to understand when thinking about metadata coming in through XML embedded in messages, is that it MUST be assumed that the incoming XML is an incomplete picture of the current state of the objects represented in the XML.  For example, often times in XML coming from streaming instruments, they will not include all attributes about the device in the XML.  This lack of information does not mean that the information has gone away, it is just that it is not included.  This is confusing, so let's illustrate.

Let's say a message comes in about the deployment of a certain device:

{{{
<DataProducer type="Deployment">
    <Device id="100" name="Widget" mfgSerialNumber="004X567"/>
</DataProducer>
}}}

In the case of devices, they should already be identified in the SSDS persistent metadata so there may be more metadata defined for that device already.  Just because the 'mfgModel' attribute is not specified in the XML, does not mean it should be removed from the existing entry in the SSDS persistent store.

The bottom line is that SSDS will have to use some rules to decide how it wants to deal with the incoming metadata, it cannot just store it blindly.  Another thing to note is that very often we SSDS will receive messages out of order, from the past, or duplicates and it must be able to deal with all of them correctly.  To fulfill it's role, here are the steps that Ruminate goes through to deal with incoming metadata.

===Ruminate Rules===

  # Extract XML payload from the JMS message
  # Create the corresponding Object graph using ObjectBuilder.
  # When a packet arrives, it can be checked against data packets that have already been received. However, thins a cannot be done by just looking in the data store as the packet will have already been stored by ingest. How do we do this? I used to use XML tracker,but that was kludgy and not very robust.
  # The ideal situation is one in which the object graph that is handed to ruminate should be handled the same regardless of how it got to ruminate.  Again, it should be thought of as an instance of objects from a graph, or portion of, that may or may not exist in SSDS already.
  # The very first thing that ruminate does is take the incoming XML and attempts to convert it straight to an SSDS object graph.
  # Next, depending on what the head object is, it should run through a set of steps to ensure the graph is "grafted" onto the information in the metadata database.
  # Let's start with DataProducer since that is the most common head object
  # We can think about the metric for equality for objects (I.e. The overridden equals method) to look for the object in the database.  This can be done using the "findEquivalentPersistantObject" method in the DAOs.