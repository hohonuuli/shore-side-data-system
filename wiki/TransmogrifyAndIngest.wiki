#summary This page describes the transmogrify and ingest components of SSDS
#sidebar TableOfContents

= Transmogrify and Ingest Components =

This page documents the components that are known as "Transmogrify" (nod to Bill Watterson here) and "Ingest". These are the components that take in data and metadata streams and perform various tasks with them as they are brought into the SSDS. There are two messaging infrastructures that are used to ingest data into the SSDS, JMS and AMQP.  JMS was the original messaging scheme and works really well, especially considering you can spin up Message Driven Beans in JBoss and JBoss will manage the pools.  This, however, limited the clients to Java for publishing messages.  While certainly fine for our initial implementation for the MOOS program, we wanted to open up the messaging to more than just Java clients.  We added an application that connects to an AMQP broker and processes messages.  This allows non-Java clients to publish packets to the SSDS.

Here is a logical diagram of the message flow for ingesting data into the SSDS.

[http://shore-side-data-system.googlecode.com/svn/wiki/images/TransIngestLogical.jpg]

They are both implemented as Message Driven Beans (EJB) and are wired in series with Transmogrify feeding into Ingest. The original reason for having both was that Transmogrify was to handle data and metadata from the SIAM system that had some special characteristics and needed to be converted to the generic message format that the SSDS is expecting. If someone wanted to send the generic format, they could bypass the Transmogrify and send straight to Ingest. As with all things, patchwork becomes production and Transmogrify lives on to this day.

Here is a sequence diagram of the basic steps that occur when a packet is submitted via JMS to the SSDS.

[http://shore-side-data-system.googlecode.com/svn/wiki/images/TransmogrifyIngest.jpg]

=== Transmogrify Packet Structure ===

Our initial and primary publisher of data for the SSDS was the SIAM infrastructure.  Initially they would publish serialized Java objects that were SIAM !DevicePacket classes.  In the SSDS, we created !SSDSDevicePacket sub classes to map the SIAM !DevicePacket information to the SSDS world.  Here is a class diagram of the classes involved:

Just as a note, the idea with the SSDSGeoLocatedDevicePacket was that if there was a way to link a particular device to another device that was providing geospatial data, you could correlate all the SSDSDevicePackets by time with that device and tag each individual packet with a geospatial reference.

When the Transmogrify component receives a SIAM !DevicePacket, it converts it to a SSDSDevicePacket using the !PacketUtility class. Here are the various attributes on the classes and how they map to each other.

|| *!DevicePacket* || *!MetadataPacket* || *!SensorDataPacket* || *!DeviceMessagePacket* || *!SensorStatusPacket* || *SSDSDevicePacket* || *SSDSGeoLocatedDevicePacket* || *Description* ||
||_sourceID||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||This is the ID of the device that generated the packet||
||_systemTime||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||This is the timestamp (in epoch milliseconds) when the packet was created by the system.  This may or may not match instrument time if the clocks are not synchronized||
||_sequenceNo||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||This is a number that should indicate the order of generation of the packet from the device||
||_metadataRef||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||This is the sequence number of the packet that contains the metadata that describes the contents of this packet.  If it is a MetadataPacket, this has no meaning.||
||_parentID||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||This is the SSDS ID of the device to which the generated device was connected when it generated this packet. Null means no parent.||
||_recordType||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_||_inherited_ but also equal the local recordType||This defines the "Type" of record that this packet contains.  Devices can send many forms of records, error messages, etc. and this help define what is actually in the payload for this message.  There are three main options here: *-1* = This means the record type has not been defined; *0* = Metadata packet which contains information about the instrument or other aspects of the observatory.  The SSDS definition of a metadata packet encompasses all the various metadata packets in SIAM.  So this means that !MetadataPacket and !DeviceMessagePacket from the SIAM world are both just tagged a record type 0. *1+* = Data packets and they can be of any kind.  The record type allows the device driver writer to group messages that are of the same format (usually).  Since the serialized class method is not used anymore, transmogrify ignores !SensorStatusPackets which were developed later and use a different serialization method.||
||X||_bytes||X||X||X||dataBuffer||_inherited_||This is a payload that contains information like service properties, SSDS XML, etc.  In the SSDSDevicePacket constructor, the _bytes buffer is mapped into the dataBuffer||
||X||_cause||X||X||X||otherBuffer||_inherited_||Another set of bytes that was meant to hold information about why the metadata packet was generated.  In the SSDSDevicePacket constructor, it is mapped to the otherBuffer||
||X||X||_dataBuffer||X||X||dataBuffer||_inherited_||This is the sample from the device that is packaged in an array of bytes.  In the SSDSDevicePacket constructor, the _dataBuffer is mapped to the dataBuffer||
||X||X||X||_message||X||dataBuffer||_inherited_||This is the message contents that are packaged into an array of bytes.  In the SSDSDevicePacket constructor, the _message is mapped to the dataBuffer||
||X||X||X||X||_statusBytes||X||X||This is the message about the instrument status as an array of bytes.  Since we broke from serialized objects before this class existed, SSDS ignores this type of object.||
||X||X||X||X||_cause||X||X||Some message, as an array of bytes, that describes why the status message was sent.  Since we broke from serialized objects before this class existed, SSDS ignores this type of object.||
||X||X||X||X||X||dataDescriptionVersion||_inherited_||This is used to indicate minor metadata changes that were not enough to create new SSDS "buckets" which were actual storage file before moving to a database.||
||X||X||X||X||X||packetType||_inherited_||This is an integer to define what type of packet this is: *0* = !MetadataPacket; *1* = !SensorDataPacket; *2* = !DeviceMessagePacket||
||X||X||X||X||X||X||longitude||Longitude where the packet was generated||
||X||X||X||X||X||X||latitude||Latitude where the packet was generated||
||X||X||X||X||X||X||depth||Depth (m) where the packet was generated||