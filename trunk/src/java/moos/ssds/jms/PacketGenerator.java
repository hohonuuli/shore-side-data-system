/*
 * Copyright 2009 MBARI
 *
 * Licensed under the GNU LESSER GENERAL PUBLIC LICENSE, Version 2.1 
 * (the "License"); you may not use this file except in compliance 
 * with the License. You may obtain a copy of the License at
 *
 * http://www.gnu.org/copyleft/lesser.html
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package moos.ssds.jms;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URL;
import java.util.Date;
import java.util.Properties;

import moos.ssds.io.util.PacketUtility;
import moos.ssds.util.XmlDateFormat;

import org.apache.log4j.Logger;

/**
 * <p>
 * This class is used to take three files created by the user and use those
 * files to create a packet to submit to the Shore Side Data System.
 * </p>
 * <hr>
 * 
 * @author : $Author: kgomes $
 * @version : $Revision: 1.6 $
 */
public class PacketGenerator {

	/**
	 * These are the two formats that the packet can be published in
	 */
	public static final String SIAM_FORMAT = "SIAM";
	public static final String SSDS_FORMAT = "SSDS";

	/**
	 * This is a Log4JLogger that is used to log information to
	 */
	private static Logger logger = Logger.getLogger(PacketGenerator.class);

	/**
	 * These are the properties that are read from a file and are used to
	 * construct a packet to send to the SSDS.
	 */
	private Properties packetProperties = new Properties();

	/**
	 * This is the PublisherComponent that the generator will use to publish its
	 * data packets.
	 */
	private PublisherComponent publisherComponent = null;

	/**
	 * This is the format of the byte array that will be constructed and it
	 * defaults to SIAM
	 */
	private String packetFormat = SIAM_FORMAT;

	/**
	 * This basically states that the bytes are coming from a SIAM
	 * ExportablePacket class. SIAM uses constants defined in the
	 * org.mbari.siam.distributed.Exportable.java class to enumerate things like
	 * this and the short value for this is always 0x0100. SSDS Doesn't really
	 * care so we essentially ignore it.
	 */
	private short streamID = 0x0100;

	/**
	 * This is the "serialVersionUID" on the class that was used to export the
	 * bytes. It is the version of SIAM class that generated the byte array.
	 * SSDS Does not really care and as of this writing, it is always 0.
	 */
	private long devicePacketVersion = 0;

	/**
	 * The ID of the device that the message was generated by.
	 */
	private long sourceID = -99;

	/**
	 * Epoch milliseconds (number of elapsed milliseconds since 1/1/1970
	 * 00:00:00) that the packet was generated by the device
	 */
	private long timestamp = 0;

	/**
	 * A number that is supposed to show the order of generation of packets from
	 * the device
	 */
	private long sequenceNumber = -99;

	/**
	 * This is the sequence number of the packet that contains the metadata that
	 * describes the information in this packet
	 */
	private long metadataRef = -99;

	/**
	 * The ID of the device that the generated device was attached to when it
	 * generated the packet
	 */
	private long parentID = -99;

	/**
	 * The type of record that this packet contains: 0 = MetadataPacket, 1 =
	 * Non-MetadataPacket (Data and other)
	 */
	private long recordType = -99;

	/**
	 * This defines the type of DevicePacket that was used to construct the byte
	 * array. The values are as follows: MetadataPacket = 0x101,
	 * SensorDataPacket = 0x102, DeviceMessagePacket = 0x103, SummaryPacket =
	 * 0x102 (same as SensorDataPacket)
	 */
	private short secondStreamID = 0x101;

	/**
	 * This is the "serialVersionUID" on the class that was used to export the
	 * bytes. It is the version of SIAM class that generated the byte array. As
	 * of this writing, it is the same as the DevicePacketVersion.
	 */
	private long secondPacketVersion = 0;

	/**
	 * This is the length of the array that holds the bytes of the first buffer
	 */
	private int firstBufferLength = 0;

	/**
	 * This is the bytes array that represents the first buffer
	 */
	private byte[] firstBuffer = null;

	/**
	 * This is the length of the array that holds the bytes of the second
	 * buffer.
	 */
	private int secondBufferLength = 0;

	/**
	 * This is the array that holds the bytes of the second buffer.
	 */
	private byte[] secondBuffer = null;

	/**
	 * This is the default constructor that creates a PublisherComponent
	 */
	public PacketGenerator() {
		// Create a new publisherComponent
		publisherComponent = new PublisherComponent();
		logger.debug("Created a new publisher and will publish messages to "
				+ publisherComponent.getTopicname() + " on host "
				+ publisherComponent.getJndiHostName());
	}

	/**
	 * Constructor that takes in a <code>File</code> which will be read. The
	 * file should contain all the appropriate properties to allow the
	 * <code>PacketGenerator</code> to construct a packet and publish it.
	 * 
	 * @param packetPropertiesFile
	 *            is the <code>File</code> that contains all the properties used
	 *            to build a data packet to send to the SSDS.
	 */
	public PacketGenerator(File packetPropertiesFile) {
		// Call the default constructor
		this();

		// Make sure file exists
		logger.debug("Constructor called with File " + packetPropertiesFile);
		if (packetPropertiesFile != null && packetPropertiesFile.exists()) {

			// Read in the properties
			try {
				Properties packetPropertiesFromFile = new Properties();
				packetPropertiesFromFile.load(new FileInputStream(
						packetPropertiesFile));
				this.setPacketProperties(packetPropertiesFromFile);
			} catch (FileNotFoundException e) {
				logger.error("FileNotFoundException caught trying to "
						+ "read properties from file " + packetPropertiesFile);
			} catch (IOException e) {
				logger.error("IOException caught trying to "
						+ "read properties from file " + packetPropertiesFile);
			}
		}
	} // End constructor

	/**
	 * This is the constructor that takes in a properties object and sets
	 * everything up locally for publishing
	 * 
	 * @param packetProperties
	 */
	public PacketGenerator(Properties packetProperties) {
		// Call default constructor
		this();

		// Set the local packet properties
		this.setPacketProperties(packetProperties);

	}

	public Properties getPacketProperties() {
		return packetProperties;
	}

	public void setPacketProperties(Properties packetProperties) {
		// Set the local variable
		this.packetProperties = packetProperties;

		// Setup the variables with these new properties
		this.setVariablesFromProperties();
	}

	public short getStreamID() {
		return streamID;
	}

	public void setStreamID(short streamID) {
		this.streamID = streamID;
	}

	public long getDevicePacketVersion() {
		return devicePacketVersion;
	}

	public void setDevicePacketVersion(long devicePacketVersion) {
		this.devicePacketVersion = devicePacketVersion;
	}

	public long getTimestamp() {
		return timestamp;
	}

	public void setTimestamp(long timestamp) {
		this.timestamp = timestamp;
	}

	public long getSequenceNumber() {
		return sequenceNumber;
	}

	public void setSequenceNumber(long sequenceNumber) {
		this.sequenceNumber = sequenceNumber;
	}

	public long getMetadataRef() {
		return metadataRef;
	}

	public void setMetadataRef(long metadataRef) {
		this.metadataRef = metadataRef;
	}

	public long getParentID() {
		return parentID;
	}

	public void setParentID(long parentID) {
		this.parentID = parentID;
	}

	public long getRecordType() {
		return recordType;
	}

	public void setRecordType(long recordType) {
		this.recordType = recordType;
	}

	public short getSecondStreamID() {
		return secondStreamID;
	}

	public void setSecondStreamID(short secondStreamID) {
		this.secondStreamID = secondStreamID;
	}

	public long getSecondPacketVersion() {
		return secondPacketVersion;
	}

	public void setSecondPacketVersion(long secondPacketVersion) {
		this.secondPacketVersion = secondPacketVersion;
	}

	public byte[] getFirstBuffer() {
		return firstBuffer;
	}

	public void setFirstBuffer(byte[] firstBuffer) {
		this.firstBuffer = firstBuffer;
	}

	public byte[] getSecondBuffer() {
		return secondBuffer;
	}

	public void setSecondBuffer(byte[] secondBuffer) {
		this.secondBuffer = secondBuffer;
	}

	public int getFirstBufferLength() {
		return firstBufferLength;
	}

	public int getSecondBufferLength() {
		return secondBufferLength;
	}

	public long getSourceID() {
		return sourceID;
	}

	public void setSourceID(long sourceID) {
		this.sourceID = sourceID;
	}

	/**
	 * This method takes the local properties object and parses through the
	 * properties to see if it can set all the variables correctly
	 */
	private void setVariablesFromProperties() {
		// Make sure properties exist
		if (packetProperties != null) {

			// Read in the format
			String packetFormatProperty = packetProperties
					.getProperty("PacketFormat");
			logger.debug("PacketFormat was specified as "
					+ packetFormatProperty);
			if (packetFormatProperty != null
					&& !packetFormatProperty.equals("")) {
				if (packetFormatProperty.equalsIgnoreCase(SSDS_FORMAT)) {
					packetFormat = SSDS_FORMAT;
				} else {
					packetFormat = SIAM_FORMAT;
				}
			}

			// First try to find a property name "StreamID"
			String streamIDProperty = packetProperties.getProperty("StreamID");
			logger.debug("StreamID from properties is " + streamIDProperty);
			if (streamIDProperty != null && !streamIDProperty.equals("")) {
				try {
					streamID = Short.decode(streamIDProperty);
				} catch (NumberFormatException e) {
					logger.error("Could not convert StreamID property of "
							+ streamIDProperty + " to a short");
				}
			}

			// Now try "DevicePacketVersion"
			String devicePacketVersionProperty = packetProperties
					.getProperty("DevicePacketVersion");
			logger.debug("DevicePacketVersion from properties is "
					+ devicePacketVersionProperty);

			// Check and convert
			if (devicePacketVersionProperty != null
					&& !devicePacketVersionProperty.equals("")) {
				try {
					devicePacketVersion = Long
							.parseLong(devicePacketVersionProperty);
				} catch (NumberFormatException e) {
					logger.error("NumberFormatException caught trying to "
							+ "convert devicePacketVersionProperty "
							+ devicePacketVersionProperty + " to a long");
				}
			}

			// Next is the "SourceID"
			String sourceIDProperty = packetProperties.getProperty("SourceID");
			logger.debug("SourceID from properties is " + sourceIDProperty);

			// Check the property
			if (sourceIDProperty != null && !sourceIDProperty.equals("")) {
				// Try to convert it to a Long
				try {
					sourceID = Long.parseLong(sourceIDProperty);
				} catch (NumberFormatException e) {
					logger.error("NumberFormatException caught trying "
							+ "to convert " + sourceIDProperty + " to a long");
				}
			}

			// As a default use the current time for timestamp
			Date currentDate = new Date();
			timestamp = currentDate.getTime();
			logger.debug("Timestamp from properties is "
					+ packetProperties.getProperty("Timestamp"));
			logger.debug("Current time in epoch millis: "
					+ currentDate.getTime());
			// Now try to parse the timestamp from the property
			XmlDateFormat xmlDateFormat = new XmlDateFormat();
			Date parsedDate = null;
			try {
				parsedDate = xmlDateFormat.parse(packetProperties
						.getProperty("Timestamp"));
			} catch (Exception e) {
				logger.error("Could not parse the timestamp "
						+ packetProperties.getProperty("Timestamp")
						+ " into a date and time: " + e.getMessage());
			}
			if (parsedDate != null) {
				timestamp = parsedDate.getTime();
				logger.debug("Parsed time in epoch millis: " + timestamp);
			}

			// Try to parse out the sequence number
			logger.debug("SequenceNumber property is "
					+ packetProperties.getProperty("SequenceNumber"));
			try {
				sequenceNumber = Long.parseLong(packetProperties
						.getProperty("SequenceNumber"));
			} catch (NumberFormatException e) {
				logger.error("Could not parse the sequence number property "
						+ packetProperties.getProperty("SequenceNumber")
						+ " into a number: " + e.getMessage());
			}
			logger.debug("After parsing, SequenceNumber is " + sequenceNumber);

			// Parse the MetadataRef
			logger.debug("MetadataRef property is "
					+ packetProperties.getProperty("MetadataRef"));
			try {
				metadataRef = Long.parseLong(packetProperties
						.getProperty("MetadataRef"));
			} catch (NumberFormatException e) {
				logger.error("Could not parse the metadata ref number "
						+ packetProperties.getProperty("MetadataRef")
						+ " into a number: " + e.getMessage());
			}
			logger.debug("MetadataRef after parsing is " + metadataRef);

			// Parse the ParentID
			logger.debug("ParentID property is "
					+ packetProperties.getProperty("ParentID"));
			try {
				parentID = Long.parseLong(packetProperties
						.getProperty("ParentID"));
			} catch (NumberFormatException e) {
				logger.error("Could not parse the parent it number "
						+ packetProperties.getProperty("ParentID")
						+ " into a number: " + e.getMessage());
			}
			logger.debug("ParentID after parsing is " + parentID);

			// Parse the RecordType
			logger.debug("RecordType property is "
					+ packetProperties.getProperty("RecordType"));
			try {
				recordType = Long.parseLong(packetProperties
						.getProperty("RecordType"));
			} catch (NumberFormatException e) {
				logger.error("Could not parse the RecordType number "
						+ packetProperties.getProperty("RecordType")
						+ " into a number: " + e.getMessage());
			}
			logger.debug("RecordType after parsing is " + recordType);

			// Parse the SecondStreamID
			logger.debug("SecondStreamID property is "
					+ packetProperties.getProperty("SecondStreamID"));
			String secondStreamIDString = packetProperties
					.getProperty("SecondStreamID");
			// Now based on the text, choose the right short
			if (secondStreamIDString.equalsIgnoreCase("METADATA")) {
				secondStreamID = 0x101;
			} else if (secondStreamIDString.equalsIgnoreCase("SENSOR_DATA")) {
				secondStreamID = 0x102;
			} else if (secondStreamIDString.equalsIgnoreCase("DEVICE_MESSAGE")) {
				secondStreamID = 0x103;
			} else {
				logger.error("Did not understand the secondStreamID of "
						+ secondStreamIDString + ", will set to SENSOR_DATA");
				secondStreamID = 0x102;
			}
			logger.debug("SecondStreamID is " + secondStreamID);

			// Parse the SecondPacketVersion
			logger.debug("SecondPacketVersion property is "
					+ packetProperties.getProperty("SecondPacketVersion"));
			try {
				secondPacketVersion = Long.parseLong(packetProperties
						.getProperty("SecondPacketVersion"));
			} catch (NumberFormatException e) {
				logger.error("Could not parse the SecondPacketVersion number "
						+ packetProperties.getProperty("SecondPacketVersion")
						+ " into a number: " + e.getMessage());
			}
			logger.debug("SecondPacketVersion after parsing is "
					+ secondPacketVersion);

			// Try to open the file and read it into the first buffer
			logger.debug("FirstBuffer property is "
					+ packetProperties.getProperty("FirstBuffer"));
			URL firstBufferUrl = ClassLoader.getSystemResource(packetProperties
					.getProperty("FirstBuffer"));
			File firstBufferFile = new File(firstBufferUrl.getFile());
			if (firstBufferFile.exists()) {
				// Open the file
				FileInputStream fis = null;
				try {
					fis = new FileInputStream(firstBufferFile);
				} catch (FileNotFoundException e) {
					logger
							.error("FirstBuffer file not found:"
									+ e.getMessage());
				}
				firstBuffer = new byte[(int) firstBufferFile.length()];
				try {
					fis.read(firstBuffer);
				} catch (IOException e) {
					logger.error("IOException trying to read "
							+ "first byte buffer from file: " + e.getMessage());
				}
				firstBufferLength = firstBuffer.length;
			} else {
				logger.debug("Doesn't look like the buffer is a file, "
						+ "so the property text will be treated as the buffer");
				if (packetProperties.getProperty("FirstBuffer") != null) {
					firstBuffer = packetProperties.getProperty("FirstBuffer")
							.getBytes();
					firstBufferLength = firstBuffer.length;
				} else {
					logger.error("No FirstBuffer property was specified");
				}
			}
			logger.debug("firstBytes is " + firstBufferLength
					+ " bytes long and is (converted to String): "
					+ new String(firstBuffer));

			// Try to open the file and read it into the second buffer
			logger.debug("SecondBuffer property is "
					+ packetProperties.getProperty("SecondBuffer"));
			URL secondBufferUrl = ClassLoader
					.getSystemResource(packetProperties
							.getProperty("SecondBuffer"));
			File secondBufferFile = new File(secondBufferUrl.getFile());
			if (secondBufferFile.exists()) {
				// Open the file
				FileInputStream fis = null;
				try {
					fis = new FileInputStream(secondBufferFile);
				} catch (FileNotFoundException e) {
					logger.error("SecondBuffer file not found:"
							+ e.getMessage());
				}
				secondBuffer = new byte[(int) secondBufferFile.length()];
				try {
					fis.read(secondBuffer);
				} catch (IOException e) {
					logger
							.error("IOException trying to read "
									+ "second byte buffer from file: "
									+ e.getMessage());
				}
				secondBufferLength = secondBuffer.length;
			} else {
				logger.debug("Doesn't look like the second buffer is a file, "
						+ "so the property text will be treated as the buffer");
				if (packetProperties.getProperty("SecondBuffer") != null) {
					secondBuffer = packetProperties.getProperty("SecondBuffer")
							.getBytes();
					secondBufferLength = secondBuffer.length;
				} else {
					logger.error("No SecondBuffer property was specified");
				}
			}
			logger.debug("secondBytes is " + secondBufferLength
					+ " bytes long and is (converted to String): "
					+ new String(secondBuffer));

		}
	}

	/**
	 * This method takes all the attributes and constructs a byte array that is
	 * in the format expected by the JMS topic in the SSDS. This can then be
	 * sent using <code>publishPacket</code>.
	 * 
	 * @return
	 */
	private byte[] createByteArrayFromAttributes() {

		// First thing is to create the SIAM format of byte array
		byte[] siamFormat = PacketUtility.createSIAMFormatByteArray(streamID,
				devicePacketVersion, sourceID, timestamp, sequenceNumber,
				metadataRef, parentID, recordType, secondStreamID,
				secondPacketVersion, firstBuffer, secondBuffer);

		// Now if that is the format requested, return it, otherwise convert to
		// SSDS format and return
		if (packetFormat.equalsIgnoreCase(SIAM_FORMAT)) {
			return siamFormat;
		} else {
			return PacketUtility.convertSIAMByteArrayToSSDSByteArray(
					siamFormat, false, false, false, false);
		}
	}

	/**
	 * This method will take the attributes that were parsed from the properties
	 * set on the <code>PacketGenerator</code>, generate a bytes array out of
	 * them, and then publish that message using the PublisherComponent
	 */
	public void publishPacket() {
		// Publish away!
		publisherComponent.publishBytes(createByteArrayFromAttributes());
	}

	/**
	 * This it the main method to start the packet generator.
	 * 
	 * @param args
	 *            is an array of strings which contains the command line
	 *            parameters. The first argument is the name of the file that
	 *            contains the properties that will be read in and used to
	 *            construct a packet to publish to the SSDS.
	 */
	public static void main(String[] args) {

		// The PacketGenerator that will be used in the main
		PacketGenerator packetGenerator = null;

		// Make sure there is one argument
		if (args == null || args.length < 1 || args.length > 1) {
			// If not print the usage message
			printUsage();
		} else {
			// There is one argument, make sure that it is an existing file on
			// the classpath
			URL url = ClassLoader.getSystemResource(args[0]);
			File propertiesFile = new File(url.getFile());
			if (!propertiesFile.exists()) {
				System.out
						.println("Could not find the packet properties file: "
								+ args[0]);
			} else {
				// Instantiate the PacketGenerator
				packetGenerator = new PacketGenerator(propertiesFile);
			}
		}

		// If it exists, send a message
		if (packetGenerator != null) {
			try {
				packetGenerator.publishPacket();
			} catch (Exception e) {
				PacketGenerator.logger.debug("Exception caught in main->"
						+ e.getMessage());
				e.printStackTrace();
			}
		}

		// Now bail out
		System.exit(0);
	}

	/**
	 * This method prints the usage information to System.out
	 */
	private static void printUsage() {
		// Print the message
		System.out
				.println("moos.ssds.jms.PacketGenerator was not called correctly.");
		System.out.println("It should be called using:");
		System.out
				.println("java -cp ssds-xxxxxx-pub.jar moos.ssds.jms.PacketGenerator packet.properties");
		System.out
				.println("where packet.properties is the name of the file that contains the properties used");
		System.out.println("to construct a packet and publish to the SSDS.");
	}
}
