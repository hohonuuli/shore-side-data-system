/*
 * Copyright 2009 MBARI
 *
 * Licensed under the GNU LESSER GENERAL PUBLIC LICENSE, Version 2.1 
 * (the "License"); you may not use this file except in compliance 
 * with the License. You may obtain a copy of the License at
 *
 * http://www.gnu.org/copyleft/lesser.html
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package moos.ssds.services.data;

import java.rmi.RemoteException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;
import javax.naming.NamingException;

import moos.ssds.dao.util.MetadataAccessException;
import moos.ssds.data.ITimeIndexedDataAccess;
import moos.ssds.data.TimeIndexedDataAccessFactory;
import moos.ssds.data.parsers.Nmea21PacketParser;
import moos.ssds.data.parsers.Nmea21RecordParser;
import moos.ssds.data.parsers.ParsingException;
import moos.ssds.data.util.DataException;
import moos.ssds.data.util.LocationAndTime;
import moos.ssds.metadata.DataContainer;
import moos.ssds.metadata.DataProducer;
import moos.ssds.metadata.Device;
import moos.ssds.metadata.RecordVariable;
import moos.ssds.services.metadata.DataProducerAccessLocal;
import moos.ssds.services.metadata.DataProducerAccessLocalHome;
import moos.ssds.services.metadata.DataProducerAccessUtil;
import moos.ssds.services.metadata.DeviceAccessLocal;
import moos.ssds.services.metadata.DeviceAccessLocalHome;
import moos.ssds.services.metadata.DeviceAccessUtil;
import moos.ssds.transmogrify.SSDSDevicePacket;

import org.apache.log4j.Logger;

/**
 * This class provides access to the data generated by a device.
 * 
 * @author kgomes
 * @ejb.bean name="DeviceDataAccess" type="Stateless"
 *           jndi-name="moos/ssds/services/data/DeviceDataAccess"
 *           local-jndi-name="moos/ssds/services/data/DeviceDataAccessLocal"
 *           view-type="both"
 * @ejb.home create="true"
 *           local-class="moos.ssds.services.data.DeviceDataAccessLocalHome"
 *           remote-class="moos.ssds.services.data.DeviceDataAccessHome"
 * @ejb.interface create="true"
 *                local-class="moos.ssds.services.data.DeviceDataAccessLocal"
 *                remote-class="moos.ssds.services.data.DeviceDataAccess"
 * @soap.service urn="DeviceDataAccess" scope="Request"
 * @axis.service urn="DeviceDataAccess" scope="Request"
 */
public class DeviceDataAccessEJB implements SessionBean {

	/**
	 * @see javax.ejb.SessionBean#ejbActivate()
	 */
	public void ejbActivate() throws EJBException, RemoteException {
	}

	/**
	 * @see javax.ejb.SessionBean#ejbPassivate()
	 */
	public void ejbPassivate() throws EJBException, RemoteException {
	}

	/**
	 * @see javax.ejb.SessionBean#ejbRemove()
	 */
	public void ejbRemove() throws EJBException, RemoteException {
	}

	/**
	 * @see javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)
	 */
	public void setSessionContext(SessionContext arg0) throws EJBException,
			RemoteException {
	}

	// The EJB Create callback
	public void ejbCreate() throws CreateException {
	}

	/**
	 * @throws CreateException
	 */
	public void ejbPostCreate() throws CreateException {
	}

	/**
	 * This method takes in a <code>Device</code>, a collection of
	 * <code>String</code>s that are the variable names, the start and end dates
	 * to span
	 * 
	 * @ejb.interface-method view-type="both"
	 * @param recordVariableID
	 * @param startTime
	 * @param endTime
	 * @return
	 */
	public Object[][] getDeviceData(Device device, Long packetSubType,
			Collection recordVariables, Date startDate, Date endDate) {

		// The object data array to return
		Object[][] data = null;

		// Make sure recordVariables are specified
		logger
				.debug("getDeviceData called, going to make sure rv's are specified");
		if ((recordVariables == null) || (recordVariables.size() <= 0)) {
			logger.debug("Nope, will return null");
			return null;
		} else {
			logger.debug("Yep, will go ahead");
		}

		// For the time axis, we can create an TreeSet to keep track of all the
		// timestamps collected from the device data.
		Collection timestamps = new TreeSet();
		logger.debug("Create timestamps TreeSet");

		// Now we need to build two arrays, one for the RecordVariable and one
		// for the data TreeMap
		String[] rvNames = new String[recordVariables.size()];
		TreeMap[] dataTreeMaps = new TreeMap[recordVariables.size()];
		int arrayIndex = 0;
		Iterator recordVariableIter = recordVariables.iterator();
		while (recordVariableIter.hasNext()) {
			String rvName = (String) recordVariableIter.next();
			rvNames[arrayIndex] = rvName;
			dataTreeMaps[arrayIndex] = new TreeMap();
			arrayIndex++;
		}

		// OK, the first thing to do is look for all deployments of this device
		// that match the time span given
		Collection deviceDeployments = null;
		try {
			DataProducerAccessLocalHome dpalh = DataProducerAccessUtil
					.getLocalHome();
			DataProducerAccessLocal dpal = dpalh.create();
			deviceDeployments = dpal.findByDeviceAndTimeWindow(device,
					startDate, endDate, null, null, false);
		} catch (NamingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (CreateException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		// Now for each deployment, grab the outputs and construct a
		// TimeIndexedDataAccess from it
		if ((deviceDeployments != null) && (deviceDeployments.size() > 0)) {
			// Now, we had an issue here when processing a large amount of data.
			// The transactions that hold the session would time out and when we
			// would try to walk the metadata object graphs, the transactions
			// were gone and would this would blow up. So, to address this, we
			// will do a premptive walk to make sure all the information is
			// available
			Iterator preemptiveIterator = deviceDeployments.iterator();
			while (preemptiveIterator.hasNext()) {
				DataProducer premptiveDataProducer = (DataProducer) preemptiveIterator
						.next();
				logger.debug("Preemptive DataProducer: "
						+ premptiveDataProducer.toStringRepresentation("|"));
				Collection preemptiveOutputs = premptiveDataProducer
						.getOutputs();
				if (preemptiveOutputs != null && preemptiveOutputs.size() > 0) {
					Iterator preemptiveOutputIter = preemptiveOutputs
							.iterator();
					while (preemptiveOutputIter.hasNext()) {
						DataContainer preemptiveOutput = (DataContainer) preemptiveOutputIter
								.next();
						logger.debug("Preemptive output: "
								+ preemptiveOutput.toStringRepresentation("|"));
						if ((preemptiveOutput != null)
								&& (preemptiveOutput.getRecordDescription() != null)
								&& (preemptiveOutput.getRecordDescription()
										.getRecordType() != null)
								&& (packetSubType != null)
								&& (preemptiveOutput.getRecordDescription()
										.getRecordType().longValue() == packetSubType
										.longValue())) {
							logger.debug("Preemptive RD: "
									+ preemptiveOutput.getRecordDescription()
											.toStringRepresentation("|"));
							// Walk the record variables
							Collection preemptiveRecordVariables = preemptiveOutput
									.getRecordDescription()
									.getRecordVariables();
							if (preemptiveRecordVariables != null
									&& preemptiveRecordVariables.size() > 0) {
								Iterator preemptiveRecordVariableIter = preemptiveRecordVariables
										.iterator();
								while (preemptiveRecordVariableIter.hasNext()) {
									logger
											.debug("Preemptive RV: "
													+ ((RecordVariable) preemptiveRecordVariableIter
															.next())
															.toStringRepresentation("|"));
								}
							}
						}
					}
				}
			}
			Iterator deploymentIter = deviceDeployments.iterator();
			while (deploymentIter.hasNext()) {
				DataProducer dataProducer = (DataProducer) deploymentIter
						.next();
				logger.debug("Going to check for output of dataProducer "
						+ dataProducer.toStringRepresentation("|"));
				// Loop over the outputs
				Collection outputs = dataProducer.getOutputs();
				if ((outputs != null) && (outputs.size() > 0)) {
					Iterator outputIter = outputs.iterator();
					while (outputIter.hasNext()) {
						DataContainer output = (DataContainer) outputIter
								.next();

						// Check to make sure the output is of the correct
						// packetSubType
						if ((output != null)
								&& (output.getRecordDescription() != null)
								&& (output.getRecordDescription()
										.getRecordType() != null)
								&& (packetSubType != null)
								&& (output.getRecordDescription()
										.getRecordType().longValue() == packetSubType
										.longValue())) {
							logger
									.debug("Going to build TimeIndexedDataAccess for output "
											+ output
													.toStringRepresentation("|"));

							// Now build the time indexed data access for the
							// output
							ITimeIndexedDataAccess outputAccess = null;
							try {
								outputAccess = TimeIndexedDataAccessFactory
										.getTimeIndexedDataAccess(output,
												startDate, endDate,
												recordVariables);
							} catch (DataException e) {
								logger
										.error("DataException caught trying to get ITimeIndexedDataAccess for "
												+ output
														.toStringRepresentation("|")
												+ ": " + e.getMessage());
							}

							// If the access object is found, loop through the
							// records and build up the top level data structure
							if (outputAccess != null) {

								logger
										.debug("Going to read in the time and data for each variable");
								Object[] times = outputAccess.getTime();

								// I am going to assume they are Long epoch
								// seconds
								// since I had control of the parsers for the
								// ITimeIndexedDataAccess
								logger.debug("There were " + times.length
										+ " timestamps found");
								for (int i = 0; i < times.length; i++) {
									Long epochTimestamp = (Long) times[i];
									// Put that in the overall times if not
									// there
									if (!timestamps.contains(epochTimestamp))
										timestamps.add(epochTimestamp);

									// Loop over all the RV names and insert the
									// data if not already in the TreeMap
									for (int rvIndex = 0; rvIndex < rvNames.length; rvIndex++) {
										if (!dataTreeMaps[rvIndex]
												.containsKey(epochTimestamp)) {
											Object[] rvData = outputAccess
													.getData(rvNames[rvIndex]);
											dataTreeMaps[rvIndex].put(
													epochTimestamp, rvData[i]);
										}
									}
								}
							}
						}
					}
				}
			}
			// So now I should have built up the data, now build the
			// multidimensional array to return
			logger.debug("OK, data should be built up, there are "
					+ timestamps.size() + " timestamps");
			logger.debug("There are " + rvNames.length + " rvs in map");
			// The overall size of the array is timestamps.size() long by
			// rvMap.size() wide
			data = new Object[timestamps.size()][rvNames.length + 1];

			// Now loop over the timestamps and fill in the objects
			Iterator dataBuildTimestampsIter = timestamps.iterator();
			int timestampCounter = 0;
			while (dataBuildTimestampsIter.hasNext()) {
				// Grab the timestamp
				Long timestamp = (Long) dataBuildTimestampsIter.next();

				// Put it in the first column at the correct index
				data[timestampCounter][0] = timestamp;

				// Now loop over and fill out across to fill in the data
				for (int rvIndex = 1; rvIndex <= rvNames.length; rvIndex++) {
					data[timestampCounter][rvIndex] = dataTreeMaps[rvIndex - 1]
							.get(timestamp);
				}

				// Increment the row
				timestampCounter++;
			}
		} else {
			logger.debug("No deployments matching those criteria found");
		}

		// Now return the result
		return data;
	}

	/**
	 * @ejb.interface-method view-type="both"
	 * @param gpsDevice
	 * @param startDate
	 * @param endDate
	 * @return
	 */
	public Collection getGpsDeviceLocationAndTimes(Device gpsDevice,
			Date startDate, Date endDate) throws DataException {
		// The Collection to return
		Collection locationAndTimes = new ArrayList();

		// Check for a matching device in SSDS
		Device persistentGpsDevice = null;
		try {
			DeviceAccessLocalHome devalh = DeviceAccessUtil.getLocalHome();
			DeviceAccessLocal deval = devalh.create();
			persistentGpsDevice = (Device) deval
					.findEquivalentPersistentObject(gpsDevice, false);
		} catch (NamingException e) {
			e.printStackTrace();
		} catch (CreateException e) {
			e.printStackTrace();
		} catch (MetadataAccessException e) {
			e.printStackTrace();
		}

		// Make sure persistent one was found
		if ((persistentGpsDevice == null)
				|| (persistentGpsDevice.getDeviceType() == null)
				|| (!persistentGpsDevice.getDeviceType().getName()
						.equalsIgnoreCase("GPS"))) {
			return locationAndTimes;
		}

		// Since the device seems like a GPS device, grab its ID
		Long deviceIDLong = persistentGpsDevice.getId();

		// Construct a NmeaPacketParser
		Nmea21PacketParser nmeaParser = new Nmea21PacketParser(
				Nmea21RecordParser.RMC_ABBR);

		// Put in the GPS recordVariables
		RecordVariable timeRV = nmeaParser.getNmea21RecordParser()
				.getTimeRecordVariable();
		RecordVariable latitudeRV = nmeaParser.getNmea21RecordParser()
				.getLatitudeRecordVariable();
		RecordVariable longitudeRV = nmeaParser.getNmea21RecordParser()
				.getLongitudeRecordVariable();

		// Next we need to pull the packets from the time range given
		TreeMap dataMap = null;
		// Try to grab the local/remote interface to the
		// SQLDataStreamRawDataAccessEJB
		SQLDataStreamRawDataAccessLocalHome sqlDSLocalHome = null;
		SQLDataStreamRawDataAccessLocal sqlDSLocal = null;
		SQLDataStreamRawDataAccessHome sqlDSHome = null;
		SQLDataStreamRawDataAccess sqlDS = null;
		try {
			sqlDSLocalHome = SQLDataStreamRawDataAccessUtil.getLocalHome();
		} catch (NamingException e) {
			logger.debug("Naming Exception caught trying to find the local "
					+ "home interface to SQLDataStreamRawDataAccess.  "
					+ "This can be OK if we are operating remotely: "
					+ e.getMessage());
		}
		if (sqlDSLocalHome == null) {
			// Try for the remote home
			try {
				sqlDSHome = SQLDataStreamRawDataAccessUtil.getHome();
			} catch (NamingException e) {
				logger
						.error("OK, I could not get the remote home SQLDataStreamRawDataAccess. "
								+ "This is a problem as I could not get the local home either!: "
								+ e.getMessage());
			}
		}
		if (sqlDSLocalHome != null) {
			try {
				sqlDSLocal = sqlDSLocalHome.create();
			} catch (CreateException e) {
				logger
						.error("Could not create the local interface to the SQL Data Service: "
								+ e.getMessage());
			}
		} else if (sqlDSHome != null) {
			try {
				sqlDS = sqlDSHome.create();
			} catch (RemoteException e) {
				logger
						.error("Could not create the remote interface to the SQL Data Service:"
								+ e.getMessage());
			} catch (CreateException e) {
				logger
						.error("Could not create the remote interface to the SQL Data Service:"
								+ e.getMessage());
			}
		}
		// Try to grab the SSDSDevicePackets
		Long startTimestampSeconds = null;
		Long startTimestampNanoseconds = null;
		Long endTimestampSeconds = null;
		Long endTimestampNanoseconds = null;
		if (startDate != null) {
			long startTimeInMillis = startDate.getTime();
			startTimestampSeconds = new Long(startTimeInMillis / 1000);
			startTimestampNanoseconds = new Long(
					startTimeInMillis % 1000 * 1000);
		} else {
			startTimestampSeconds = new Long(0);
			startTimestampNanoseconds = new Long(0);
		}
		if (endDate != null) {
			long endTimeInMillis = endDate.getTime();
			endTimestampSeconds = new Long(endTimeInMillis / 1000);
			endTimestampNanoseconds = new Long(endTimeInMillis % 1000 * 1000);
		} else {
			Date currentDate = new Date();
			long endTimeInMillis = currentDate.getTime();
			endTimestampSeconds = new Long(endTimeInMillis / 1000);
			endTimestampNanoseconds = new Long(endTimeInMillis % 1000 * 1000);
		}
		if (sqlDSLocal != null) {
			try {
				dataMap = sqlDSLocal.getSortedRawData(deviceIDLong, null, null,
						null, null, new Long(1), null, null, null, null, null,
						startTimestampSeconds, endTimestampSeconds,
						startTimestampNanoseconds, endTimestampNanoseconds,
						null, null, null, null, null, null, null, null, null,
						SQLDataStreamRawDataAccessEJB.BY_TIMESTAMP, true);
			} catch (SQLException e) {
				throw new DataException(e.getMessage());
			}
		} else {
			try {
				dataMap = sqlDS.getSortedRawData(deviceIDLong, null, null,
						null, null, new Long(1), null, null, null, null, null,
						startTimestampSeconds, endTimestampSeconds,
						startTimestampNanoseconds, endTimestampNanoseconds,
						null, null, null, null, null, null, null, null, null,
						SQLDataStreamRawDataAccessEJB.BY_TIMESTAMP, true);
			} catch (RemoteException e) {
				throw new DataException(e.getMessage());
			} catch (SQLException e) {
				throw new DataException(e.getMessage());
			}
		}

		// Now the TreeMap contains a mapping between timestamp and a Collection
		// of records. This is to support multiple recordTypes from one stream.
		// In this case it should be a one-to-one associated, but we still need
		// to extract out all the individual records into one Collection
		ArrayList packets = new ArrayList();
		if (dataMap != null) {
			Iterator dataMapValueIterator = dataMap.values().iterator();
			while (dataMapValueIterator.hasNext()) {
				packets.addAll((Collection) dataMapValueIterator.next());
			}
		}

		// So I now have all the SSDSDevicePackets from the GPS device in one
		// collection over the time frame given. They should also be in
		// timestamp
		// order, so I can simply iterate over the collection and create
		// Locations
		// and times from the packets
		Iterator packetIterator = packets.iterator();
		while (packetIterator.hasNext()) {
			// Grab the packet and parse
			Map rvToDataMap = null;
			try {
				rvToDataMap = nmeaParser
						.parse((SSDSDevicePacket) packetIterator.next());
			} catch (ParsingException e) {
			}

			// So we should have time, grid_latitude, and grid_longitude RVs and
			// data so I can now create LocationAndTimes
			if (rvToDataMap != null)
				locationAndTimes.add(new LocationAndTime((Double) rvToDataMap
						.get(latitudeRV),
						(Double) rvToDataMap.get(longitudeRV), null,
						(Long) rvToDataMap.get(timeRV)));
		}

		// Return the results
		return locationAndTimes;
	}

	/**
	 * This method takes in a <code>Device</code> and a time window and returns
	 * a collection of <code>LocationAndTime</code> objects that will be sorted
	 * be ascending time.
	 * 
	 * @ejb.interface-method view-type="both"
	 * @param device
	 * @param startDate
	 * @param endDate
	 * @return
	 */
	public Collection getDeviceLocationAndTimes(Device device, Date startDate,
			Date endDate) {
		// The Collection to Return
		Collection locationAndTimes = new ArrayList();
		TreeMap sortedLocationAndTimes = new TreeMap();

		// First check to see if the device is of type GPS. If so, then simply
		// grab the NmeaPacketParser and go to town
		if (device != null) {
			// The TreeMap of GPS Device's to their time frame
			TreeMap gpsDevices = new TreeMap();

			// Check for a matching device in SSDS
			Device persistentDevice = null;
			try {
				DeviceAccessLocalHome devalh = DeviceAccessUtil.getLocalHome();
				DeviceAccessLocal deval = devalh.create();
				persistentDevice = (Device) deval
						.findEquivalentPersistentObject(device, false);
			} catch (NamingException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (CreateException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (MetadataAccessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			// If the device is a GPS, grab the packet parse straight up
			if (persistentDevice != null) {
				if ((persistentDevice.getDeviceType() != null)
						&& (persistentDevice.getDeviceType().getName()
								.equalsIgnoreCase("gps"))) {
					// Create the array of start and end dates
					Date[] dateRange = new Date[2];
					dateRange[0] = startDate;
					dateRange[1] = endDate;
					gpsDevices.put(persistentDevice, dateRange);
				} else {
					// TODO kgomes, I need to search for the deployments and
					// stitch together the GPS's over the time window given
				}
			}

			// I should now have the TreeMap with the GPS devices and their
			// respective time frames, so we can iterate over each
			Set gpsDeviceSet = gpsDevices.keySet();
			Iterator gpsDeviceIter = gpsDeviceSet.iterator();
			while (gpsDeviceIter.hasNext()) {
				// Grab the GPS
				Device gpsDevice = (Device) gpsDeviceIter.next();
				// Grab the start and end dates
				Date[] gpsDateRange = (Date[]) gpsDevices.get(gpsDevice);
				Date gpsStartDate = gpsDateRange[0];
				Date gpsEndDate = gpsDateRange[1];

			}
		}

		// Return the results
		return locationAndTimes;
	}

	/**
	 * This is a Log4JLogger that is used to log information to
	 */
	static Logger logger = Logger.getLogger(DeviceDataAccessEJB.class);
}